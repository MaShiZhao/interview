package interview.msz.com.net;

import android.os.Bundle;
import android.support.annotation.Nullable;

import interview.msz.com.baseActivity.BaseActivity;

/**
 * Created by MaShiZhao on 2018/4/17.
 */

public class SocketActivity extends BaseActivity
{

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setTitle("socket");
        String contentS1 = " 建立socket连接\n" +
                "建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。\n" +
                "\n" +
                "套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。\n" +
                "\n" +
                "服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。\n" +
                "\n" +
                "客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。\n" +
                "\n" +
                "连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。\n";


        String contentS = "1.网络基础\n" +
                "1.1 计算机网络分层\n" +
                "计算机网络分为五层：物理层、数据链路层、网络层、运输层、应用层\n" +
                "\n" +
                "计算机网络\n" +
                "\n" +
                "其中：\n" +
                "\n" +
                "网络层：负责根据IP找到目的地址的主机\n" +
                "运输层：通过端口把数据传到目的主机的目的进程，来实现进程与进程之间的通信\n" +
                "1.2 端口号（PORT）\n" +
                "端口号规定为16位，即允许一个IP主机有2的16次方65535个不同的端口。其中：\n" +
                "\n" +
                "0~1023：分配给系统的端口号 \n" +
                "我们不可以乱用\n" +
                "\n" +
                "1024~49151：登记端口号，主要是让第三方应用使用\n" +
                "\n" +
                "但是必须在IANA（互联网数字分配机构）按照规定手续登记，\n" +
                "\n" +
                "49152~65535：短暂端口号，是留给客户进程选择暂时使用，一个进程使用完就可以供其他进程使用。\n" +
                "\n" +
                "在Socket使用时，可以用1024~65535的端口号\n" +
                "\n" +
                "1.3 C/S结构\n" +
                "定义：即客户端/服务器结构，是软件系统体系结构\n" +
                "作用：充分利用两端硬件环境的优势，将任务合理分配到Client端和Server端来实现，降低了系统的通讯开销。 \n" +
                "Socket正是使用这种结构建立连接的，一个套接字接客户端，一个套接字接服务器。\n" +
                "\n" +
                "\n" +
                "如图：Socket架构\n" +
                "可以看出，Socket的使用可以基于TCP或者UDP协议。\n" +
                "1.4 TCP协议\n" +
                "定义：Transmission Control Protocol，即传输控制协议，是一种传输层通信协议 \n" +
                "基于TCP的应用层协议有FTP、Telnet、SMTP、HTTP、POP3与DNS。\n" +
                "\n" +
                "特点：面向连接、面向字节流、全双工通信、可靠\n" +
                "\n" +
                "面向连接：指的是要使用TCP传输数据，必须先建立TCP连接，传输完成后释放连接，就像打电话一样必须先拨号建立一条连接，打完后挂机释放连接。\n" +
                "\n" +
                "全双工通信：即一旦建立了TCP连接，通信双方可以在任何时候都能发送数据。\n" +
                "\n" +
                "可靠的：指的是通过TCP连接传送的数据，无差错，不丢失，不重复，并且按序到达。\n" +
                "\n" +
                "面向字节流：流，指的是流入到进程或从进程流出的字符序列。简单来说，虽然有时候要传输的数据流太大，TCP报文长度有限制，不能一次传输完，要把它分为好几个数据块，但是由于可靠性保证，接收方可以按顺序接收数据块然后重新组成分块之前的数据流，所以TCP看起来就像直接互相传输字节流一样，面向字节流。\n" +
                "\n" +
                "TCP建立连接 \n" +
                "必须进行三次握手：若A要与B进行连接，则必须 \n" +
                "第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认。即A发送信息给B\n" +
                "第二次握手：服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认。即B收到连接信息后向A返回确认信息\n" +
                "第三次握手：客户端收到服务器的（SYN+ACK）报文段，并向服务器发送ACK报文段。即A收到确认信息后再次向B返回确认连接信息 \n" +
                "此时，A告诉自己上层连接建立；B收到连接信息后告诉上层连接建立。\n" +
                "\n" +
                "TCP三次握手\n" +
                "\n" +
                "这样就完成TCP三次握手 = 一条TCP连接建立完成 = 可以开始发送数据\n" +
                "\n" +
                "三次握手期间任何一次未收到对面回复都要重发。\n" +
                "最后一个确认报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态。\n" +
                "为什么TCP建立连接需要三次握手？\n" +
                "答：防止服务器端因为接收了早已失效的连接请求报文从而一直等待客户端请求，从而浪费资源\n" +
                "\n" +
                "“已失效的连接请求报文段”的产生在这样一种情况下：Client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。\n" +
                "这是一个早已失效的报文段。但Server收到此失效的连接请求报文段后，就误认为是Client再次发出的一个新的连接请求。\n" +
                "于是就向Client发出确认报文段，同意建立连接。\n" +
                "假设不采用“三次握手”：只要Server发出确认，新的连接就建立了。\n" +
                "由于现在Client并没有发出建立连接的请求，因此不会向Server发送数据。\n" +
                "但Server却以为新的运输连接已经建立，并一直等待Client发来数据。>- 这样，Server的资源就白白浪费掉了。\n" +
                "采用“三次握手”的办法可以防止上述现象发生：\n" +
                "\n" +
                "Client不会向Server的确认发出确认\n" +
                "Server由于收不到确认，就知道Client并没有要求建立连接\n" +
                "所以Server不会等待Client发送数据，资源就没有被浪费\n" +
                "\n" +
                "TCP释放连接 \n" +
                "TCP释放连接需要四次挥手过程，现在假设A主动释放连接：（数据传输结束后，通信的双方都可释放连接）\n" +
                "\n" +
                "第一次挥手：A发送释放信息到B；（发出去之后，A->B发送数据这条路径就断了）\n" +
                "第二次挥手：B收到A的释放信息之后，回复确认释放的信息：我同意你的释放连接请求\n" +
                "\n" +
                "第三次挥手：B发送“请求释放连接“信息给A\n" +
                "\n" +
                "第四次挥手：A收到B发送的信息后向B发送确认释放信息：我同意你的释放连接请求\n" +
                "\n" +
                "B收到确认信息后就会正式关闭连接； \n" +
                "A等待2MSL后依然没有收到回复，则证明B端已正常关闭，于是A关闭连接\n" +
                "\n" +
                "TCp四次握手\n" +
                "\n" +
                "为什么TCP释放连接需要四次挥手？\n" +
                "为了保证双方都能通知对方“需要释放连接”，即在释放连接后都无法接收或发送消息给对方\n" +
                "\n" +
                "需要明确的是：TCP是全双工模式，这意味着是双向都可以发送、接收的\n" +
                "释放连接的定义是：双方都无法接收或发送消息给对方，是双向的\n" +
                "当主机1发出“释放连接请求”（FIN报文段）时，只是表示主机1已经没有数据要发送 / 数据已经全部发送完毕； \n" +
                "但是，这个时候主机1还是可以接受来自主机2的数据。\n" +
                "当主机2返回“确认释放连接”信息（ACK报文段）时，表示它已经知道主机1没有数据发送了 \n" +
                "但此时主机2还是可以发送数据给主机1\n" +
                "当主机2也发送了FIN报文段时，即告诉主机1我也没有数据要发送了 \n" +
                "此时，主机1和2已经无法进行通信：主机1无法发送数据给主机2，主机2也无法发送数据给主机1，此时，TCP的连接才算释放\n" +
                "1.5 UDP协议\n" +
                "定义：User Datagram Protocol，即用户数据报协议，是一种传输层通信协议。\n" +
                "\n" +
                "基于UDP的应用层协议有TFTP、SNMP与DNS。\n" +
                "\n" +
                "特点：无连接的、不可靠的、面向报文、没有拥塞控制\n" +
                "\n" +
                "无连接的：和TCP要建立连接不同，UDP传输数据不需要建立连接，就像写信，在信封写上收信人名称、地址就可以交给邮局发送了，至于能不能送到，就要看邮局的送信能力和送信过程的困难程度了。\n" +
                "\n" +
                "不可靠的：因为UDP发出去的数据包发出去就不管了，不管它会不会到达，所以很可能会出现丢包现象，使传输的数据出错。\n" +
                "\n" +
                "面向报文：数据报文，就相当于一个数据包，应用层交给UDP多大的数据包，UDP就照样发送，不会像TCP那样拆分。\n" +
                "\n" +
                "没有拥塞控制：拥塞，是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象，就像交通堵塞一样。TCP建立连接后如果发送的数据因为信道质量的原因不能到达目的地，它会不断重发，有可能导致越来越塞，所以需要一个复杂的原理来控制拥塞。而UDP就没有这个烦恼，发出去就不管了。\n" +
                "应用场景 \n" +
                "很多的实时应用（如IP电话、实时视频会议、某些多人同时在线游戏等）要求源主机以很定的速率发送数据，并且允许在网络发生拥塞时候丢失一些数据，但是要求不能有太大的延时，UDP就刚好适合这种要求。所以说，只有不适合的技术，没有真正没用的技术。\n" +
                "\n" +
                "1.6 HTTP协议\n" +
                "详情请看我写的另外一篇文章你需要了解的HTTP知识都在这里了！\n" +
                "\n" +
                "2. Socket定义\n" +
                "即套接字，是一个对 TCP / IP协议进行封装 的编程调用接口（API）\n" +
                "\n" +
                "即通过Socket，我们才能在Andorid平台上通过 TCP/IP协议进行开发\n" +
                "Socket不是一种协议，而是一个编程调用接口（API），属于传输层（主要解决数据如何在网络中传输）\n" +
                "成对出现，一对套接字：\n" +
                "\n" +
                "Socket ={(IP地址1:PORT端口号)，(IP地址2:PORT端口号)}\n" +
                "1\n" +
                "3. 原理\n" +
                "Socket的使用类型主要有两种：\n" +
                "\n" +
                "流套接字（streamsocket） ：基于 TCP协议，采用 流的方式 提供可靠的字节流服务\n" +
                "数据报套接字(datagramsocket)：基于 UDP协议，采用 数据报文 提供数据打包发送的服务\n" +
                "具体原理图如下：\n" +
                "\n" +
                "原理图\n" +
                "\n" +
                "4. Socket 与 Http 对比\n" +
                "Socket属于传输层，因为 TCP / IP协议属于传输层，解决的是数据如何在网络中传输的问题\n" +
                "HTTP协议 属于 应用层，解决的是如何包装数据\n" +
                "由于二者不属于同一层面，所以本来是没有可比性的。但随着发展，默认的Http里封装了下面几层的使用，所以才会出现Socket & HTTP协议的对比：（主要是工作方式的不同）：\n" +
                "\n" +
                "Http：采用 请求—响应 方式。\n" +
                "\n" +
                "即建立网络连接后，当 客户端 向 服务器 发送请求后，服务器端才能向客户端返回数据。\n" +
                "可理解为：是客户端有需要才进行通信\n" +
                "Socket：采用 服务器主动发送数据 的方式\n" +
                "\n" +
                "即建立网络连接后，服务器可主动发送消息给客户端，而不需要由客户端向服务器发送请求\n" +
                "可理解为：是服务器端有需要才进行通信";

        setContentTextView(contentS1 + "\n\n\n" + contentS);

        gotoActivity("https://blog.csdn.net/carson_ho/article/details/53366856");


    }


}
